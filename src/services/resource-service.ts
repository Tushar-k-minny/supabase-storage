import { isSupabaseConfigured, supabase } from "../config/supabase.js";
import type { Resource, ResourceResponse } from "../types/api-types.js";
import { logger } from "../utils/logger.js";

const WHITESPACE_REGEX = /\s+/;

export const generateMockAnswer = (query: string): string => {
  const normalizedQuery = query.toLowerCase();

  if (normalizedQuery.includes("rag")) {
    return "Retrieval-Augmented Generation (RAG) is a technique that combines information retrieval with text generation. It enhances language models by first retrieving relevant documents from a knowledge base, then using those documents as additional context when generating responses. This approach helps reduce hallucinations and keeps responses grounded in factual information.";
  }

  if (
    normalizedQuery.includes("machine learning") ||
    normalizedQuery.includes("ml")
  ) {
    return "Machine Learning is a subset of artificial intelligence that enables systems to learn and improve from experience without being explicitly programmed. It focuses on developing algorithms that can access data and use it to learn for themselves. Common types include supervised learning, unsupervised learning, and reinforcement learning.";
  }

  if (normalizedQuery.includes("neural network")) {
    return "Neural networks are computing systems inspired by biological neural networks in the brain. They consist of interconnected nodes (neurons) organized in layers that process information. Deep neural networks with many layers have revolutionized tasks like image recognition, natural language processing, and game playing.";
  }

  if (normalizedQuery.includes("transformer")) {
    return `Transformers are a type of neural network architecture that uses self-attention mechanisms to process sequential data. Introduced in the paper "Attention Is All You Need" (2017), they have become the foundation for modern large language models like GPT, BERT, and Claude. Their key innovation is processing all tokens in parallel rather than sequentially.`;
  }

  return `This is a comprehensive answer for your query: "${query}". Jiji has analyzed your question and found relevant learning resources. In a production environment, this response would be generated by an AI model using RAG to provide accurate, contextual information based on your learning materials.`;
};

export const searchResources = async (
  query: string
): Promise<ResourceResponse[]> => {
  if (!(isSupabaseConfigured && supabase)) {
    logger.warn("Supabase not configured, returning empty resources");
    return [];
  }

  try {
    const searchTerms = query
      .toLowerCase()
      .split(WHITESPACE_REGEX)
      .filter((term) => term.length > 2);

    console.log("query", query, "/n", searchTerms, ":::searchTerms");

    if (searchTerms.length === 0) {
      return [];
    }

    const { data, error } = await supabase
      .from("resources")
      .select("id, title, description, type, file_url, tags, created_at")
      .or(
        searchTerms
          .map((term) => `title.ilike.%${term}%,description.ilike.%${term}%`)
          .join(",")
      )
      .limit(10);

    if (error) {
      logger.error(
        { error: String(error) },
        "Error fetching resources from Supabase"
      );
      return [];
    }

    if (!data || data.length === 0) {
      const { data: tagData, error: tagError } = await supabase
        .from("resources")
        .select("id, title, description, type, file_url, tags, created_at")
        .overlaps("tags", searchTerms)
        .limit(10);

      if (tagError) {
        logger.error(
          { error: String(tagError) },
          "Error fetching resources by tags"
        );
        return [];
      }

      if (tagData && tagData.length > 0) {
        return mapResourcesToResponse(tagData as Resource[]);
      }

      return [];
    }

    return mapResourcesToResponse(data as Resource[]);
  } catch (error) {
    logger.error(
      { error: String(error) },
      "Unexpected error in searchResources"
    );
    return [];
  }
};

const mapResourcesToResponse = (resources: Resource[]): ResourceResponse[] => {
  return resources.map((resource) => ({
    id: resource.id,
    title: resource.title,
    type: resource.type,
    url: resource.file_url,
  }));
};

export const getAllResources = async (): Promise<ResourceResponse[]> => {
  if (!(isSupabaseConfigured && supabase)) {
    logger.warn("Supabase not configured, returning empty resources");
    return [];
  }

  try {
    const { data, error } = await supabase
      .from("resources")
      .select("id, title, description, type, file_url, tags, created_at")
      .order("created_at", { ascending: false })
      .limit(50);

    if (error) {
      logger.error({ error: String(error) }, "Error fetching all resources");
      return [];
    }

    return mapResourcesToResponse((data as Resource[]) || []);
  } catch (error) {
    logger.error(
      { error: String(error) },
      "Unexpected error in getAllResources"
    );
    return [];
  }
};
